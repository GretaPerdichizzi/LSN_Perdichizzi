#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <numeric>
#include "Chromosome.h"


using namespace std;

Chromosome :: Chromosome(){}

Chromosome :: ~Chromosome(){}

//Initialize the world
void Chromosome :: World_Init(){
	
	//Importing initial cities configurations
		ifstream ReadConf;
		//cout << "Read initial configuration from file config.0" << endl << endl;
		ReadConf.open("config.square");
		for (int i=0; i<n_cities; ++i){
		  ReadConf >> coord.x >> coord.y;						
			chromo.push_back(coord);
		}
		ReadConf.close();
		City1.x=chromo[0].x;
		City1.y=chromo[0].y;
}


//Cost/loss function L(1)
double Chromosome :: L1(){
	double sum=0;
	for(int i=0; i<n_cities; i++){
		sum+=sqrt(pow((chromo[i].x-chromo[i+1].x),2)+pow((chromo[i].y-chromo[i+1].y),2));
	}
	sum+=sqrt(pow((chromo[n_cities-1].x-chromo[0].x),2)+pow((chromo[n_cities-1].y-chromo[0].y),2));
	return sum;
}

//MUTATIONS//

//Pair permutation of 2 random genes
void Chromosome :: PairPerm(Random &random){
	rnd = &random; //starting from the last random number generated by rnd
	vector<City>::iterator iterator1 = chromo.begin(); //Chromo is my <vector> of City
	vector<City>::iterator iterator2 = chromo.begin();
	advance (iterator1, int(rnd->Rannyu(1,n_cities)));
	advance (iterator2, int(rnd->Rannyu(1,n_cities)));
	iter_swap(iterator1, iterator2);
}

//Shift of n positions m contiguous cities
void Chromosome :: Shift(Random &random){
	rnd = &random;
	int n=0;
	n = int (rnd->Rannyu(1,n_cities));
	rotate(chromo.begin()+1, chromo.begin()+n, chromo.end()); //the n-th element become the 2-nd and the others n-to-end follow the n-th (so I shift m=end-n contiguous cities)
}

//Permutation of m contiguous cities
void Chromosome :: GroupPerm(Random &random){
	rnd = &random;
	int m = int(rnd->Rannyu(1, n_cities/2)); // m (contiguous cities)
	int delta = int(rnd->Rannyu(1, n_cities-2*m)); //distance from the first to the second group of cities (min 1 to not overlap) 
	int initial1 = int(rnd->Rannyu(1, n_cities-2*m-delta)); // starting city of the 1st group (end of the vector - twice the lenght of the groups - delta from groups)
	int initial2 = initial1+m+delta; //starting city of the 2nd group to swap
	swap_ranges(chromo.begin()+initial1, chromo.begin()+initial1+m, chromo.begin()+initial2);
}

//Inversion
void Chromosome :: Inversion(Random &random){
	rnd = &random;
	int m = int(rnd->Rannyu(1, n_cities));  //how many cities I want to invert
	int initial1 = int (rnd->Rannyu(1, n_cities-m)); //starting city of the interval to be inverted
	reverse(chromo.begin()+initial1, chromo.begin()+initial1+m);
}


